# -*- coding: utf-8 -*-
"""LAB_4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Y0Q09fMaMKODBl4R4z9RgTx2ZMfhYQjQ

Subir archivo
"""

from google.colab import files
uploaded = files.upload()
import pandas as pd

"""###**Parte A**
> a y b.


"""

import numpy as np
import matplotlib.pyplot as plt

with open('Senal_lab_4_partea_ver3.txt', 'r') as f:
    contenido = f.read()

datos = np.array(contenido.split(), dtype=float)

mitad = len(datos)//2
t = datos[:mitad]
senal = datos[mitad:]

print(f"Longitud tiempo: {len(t)} | Longitud señal: {len(senal)}")

plt.figure(figsize=(8,4))
plt.plot(t, senal, color='midnightblue')
plt.title(f"fs={1/(t[1]-t[0]):.0f}Hz, duración={t[-1]:.1f}s, muestras={len(senal)}")
plt.xlabel("Tiempo (s)")
plt.ylabel("Amplitud (V)")
plt.grid(True)
plt.show()

"""

> c.


"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import butter, filtfilt

fs = 2000  # Hz

senal_proc = np.abs(senal - np.mean(senal))

#filtro pasabajos
b, a = butter(2, 2 / (fs / 2), btype='low')
filtrada = filtfilt(b, a, senal_proc)

#normalizar
filtrada_norm = filtrada / np.max(filtrada)

#deteccion de umbrales, cuando pasa el umbral inicia una contraccion y cuando vuelve a estar debajo del umbral se termina la contraccion
umbral = np.mean(filtrada_norm) + 0.5 * np.std(filtrada_norm)
en_contraccion = filtrada_norm > umbral
inicios = np.where(np.diff(en_contraccion.astype(int)) == 1)[0]
fines = np.where(np.diff(en_contraccion.astype(int)) == -1)[0]

if len(fines) < len(inicios):
    fines = np.append(fines, len(senal) - 1)
elif len(fines) > len(inicios):
    fines = fines[:len(inicios)]

print(f"Contracciones detectadas: {len(inicios)}")

plt.figure(figsize=(12, 4))
plt.plot(t, senal / np.max(np.abs(senal)), label="Señal EMG", color='hotpink', alpha=0.7)
plt.plot(t, filtrada_norm, label="Señal filtrada", color='palevioletred', linewidth=2)

for ini, fin in zip(inicios, fines):
    plt.axvspan(t[ini], t[fin], color='skyblue', alpha=0.3)

plt.xlabel('Tiempo (s)')
plt.ylabel('Amplitud (V)')
plt.title('Detección y segmentación de contracciones musculares simuladas')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

segmentos = [senal[ini:fin] for ini, fin in zip(inicios, fines)]
print(f"Se extrajeron {len(segmentos)} segmentos.")

"""

> d.

"""

import numpy as np

def analizar_segmento(segmento, fs):
    N = len(segmento)
    if N < 2:
        return 0, 0

    ventana = np.hanning(N)
    fft_vals = np.fft.fft(segmento * ventana)
    freqs = np.fft.fftfreq(N, 1/fs)
    freqs = freqs[:N//2]
    potencia = np.abs(fft_vals[:N//2])**2

    potencia[0] = 0

    if np.sum(potencia) < 1e-12:
        return 0, 0

    f_mean = np.sum(freqs * potencia) / np.sum(potencia)

    potencia_acum = np.cumsum(potencia)
    mitad_potencia = potencia_acum[-1] / 2
    idx_median = np.where(potencia_acum >= mitad_potencia)[0]
    f_median = freqs[idx_median[0]] if len(idx_median) > 0 else 0

    return f_mean, f_median

for i, (ini, fin) in enumerate(zip(inicios, fines), start=1):
    t_seg = t[ini:fin]
    senal_seg = senal[ini:fin]

    plt.figure(figsize=(6, 2))
    plt.plot(t_seg, senal_seg, color='mediumvioletred')
    plt.title(f"Contracción {i}")
    plt.xlabel("Tiempo (s)")
    plt.ylabel("Amplitud (V)")
    plt.grid(True, linestyle='--', alpha=0.6)
    plt.tight_layout()
    plt.show()

"""

> e.

"""

resultados = []
for i, seg in enumerate(segmentos):
    f_mean, f_median = analizar_segmento(seg, fs)
    resultados.append((i+1, f_mean, f_median))

print("Contracción | Frecuencia media (Hz) | Frecuencia mediana (Hz)")
for r in resultados:
    print(f"{r[0]:11.2f} | {r[1]:21.2f} | {r[2]:21.2f}")

resultados = np.array(resultados)
contracciones = resultados[:, 0]
f_media = resultados[:, 1]
f_mediana = resultados[:, 2]

plt.figure(figsize=(8, 4))
plt.plot(contracciones, f_media, marker='*', color='indigo')
plt.title('Frecuencia media por contracción')
plt.xlabel('Número de contracción')
plt.ylabel('Frecuencia (Hz)')
plt.grid(True)
plt.show()

plt.figure(figsize=(8 ,4))
plt.plot(contracciones, f_mediana, marker='*', color='deeppink')
plt.title('Frecuencia mediana por contracción')
plt.xlabel('Número de contracción')
plt.ylabel('Frecuancia (Hz)')
plt.grid(True)


plt.tight_layout()
plt.show()

"""###**Parte B**


> b.

Subir otro archivo
"""

from google.colab import files
uploaded = files.upload()

import numpy as np
import matplotlib.pyplot as plt

emg = np.loadtxt('senal_EMG__5_mejor_mejor_mejor220251029_144237.txt', comments='#')
fs = 10000

t2= emg[:, 0]
senal2 = emg[:, 1]

inicioo = t2 <= 10
ti= t2[inicioo]
si= senal2[inicioo]

tf = t2.max()
finall = t2 >= (tf -10)
tf = t2[finall]
sf =senal2[finall]

plt.figure(figsize=(12, 6))

plt.subplot(2,1,1)
plt.plot(ti, si, color='mediumaquamarine')
plt.title("Señal original, actividad normal")
plt.xlabel("Tiempo (s)")
plt.ylabel("Amplitud (V)")
plt.grid(True)

plt.subplot(2,1,2)
plt.plot(tf, sf, color='mediumaquamarine')
plt.title("Señal original, fatiga")
plt.xlabel("Tiempo (s)")
plt.ylabel("Amplitud (V)")
plt.grid(True)

plt.tight_layout()
plt.show()

"""

> c.

"""

from scipy.signal import butter, filtfilt
import numpy as np
import matplotlib.pyplot as plt

#filtro
def butter_bandpass(lowcut, highcut, fs, order=4):
    nyq = 0.5 * fs
    low = lowcut / nyq
    high = highcut / nyq
    b, a = butter(order, [low, high], btype='band')
    return b, a

def aplicar_filtro(data, lowcut, highcut, fs, order=4):
    b, a = butter_bandpass(lowcut, highcut, fs, order=order)
    y = filtfilt(b, a, data)
    return y

t2 = emg[:, 0]
senal2 = emg[:, 1]

senal_filtrada = aplicar_filtro(senal2, 20, 450, fs, order=4)

inicioo = t2 <= 10
ti= t2[inicioo]
si2= senal_filtrada[inicioo]

tf = t2.max()
finall = t2 >= (tf -10)
tf = t2[finall]
sf2 =senal_filtrada[finall]
plt.figure(figsize=(12, 6))

plt.subplot(2,1,1)
plt.plot(ti, si2, color='darkorchid')
plt.title("Señal filtrada, actividad normal")
plt.xlabel("Tiempo (s)")
plt.ylabel("Amplitud (V)")
plt.grid(True)

plt.subplot(2,1,2)
plt.plot(tf, sf2, color='darkorchid')
plt.title("Señal filtrada, fatiga")
plt.xlabel("Tiempo (s)")
plt.ylabel("Amplitud (V)")
plt.grid(True)

plt.tight_layout()
plt.show()

"""

> d.

"""

#deteccion de umbrales, cuando pasa el umbral inicia una contraccion y cuando vuelve a estar debajo del umbral se termina la contraccion
umbral = np.mean(senal_filtrada) + 0.5 * np.std(senal_filtrada)
contraccion2 = senal_filtrada > umbral
inicios2 = np.where(np.diff(contraccion2.astype(int)) == 1)[0]
fines2 = np.where(np.diff(contraccion2.astype(int)) == -1)[0]

if len(fines2) < len(inicios2):
    fines2 = np.append(fines2, len(senal) - 1)
elif len(fines2) > len(inicios2):
    fines2 = fines2[:len(inicios2)]

print(f"Contracciones detectadas: {len(inicios2)}")

plt.figure(figsize=(12, 4))
plt.plot(t2, senal_filtrada / np.max(np.abs(senal_filtrada)), label="Señal EMG", color='darkgoldenrod', alpha=0.7)

for ini, fin in zip(inicios2, fines2):
    plt.axvspan(t2[ini], t2[fin], color='lightpink', alpha=0.3)

plt.xlabel('Tiempo (s)')
plt.ylabel('Amplitud (V)')
plt.title('Detección y segmentación de contracciones musculares capturadas')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

segmentos2 = [senal_filtrada[ini:fin] for ini, fin in zip(inicios2, fines2)]
print(f"Se extrajeron {len(segmentos2)} segmentos.")

"""

> e.

"""

import numpy as np

def analizar_segmento2(segmento, fs):
    N = len(segmento)
    if N < 2:
        return 0, 0

    ventana = np.hanning(N)
    fft_vals = np.fft.fft(segmento * ventana)
    freqs = np.fft.fftfreq(N, 1/fs)
    freqs = freqs[:N//2]
    potencia = np.abs(fft_vals[:N//2])**2

    potencia[0] = 0

    if np.sum(potencia) < 1e-12:
        return 0, 0

    f_mean2 = np.sum(freqs * potencia) / np.sum(potencia)

    potencia_acum = np.cumsum(potencia)
    mitad_potencia = potencia_acum[-1] / 2
    idx_median = np.where(potencia_acum >= mitad_potencia)[0]
    f_median2 = freqs[idx_median[0]] if len(idx_median) > 0 else 0

    return f_mean2, f_median2

resultados2 = []
for i, seg in enumerate(segmentos2):
    f_mean2, f_median2 = analizar_segmento2(seg, fs)
    resultados2.append((i+1, f_mean2, f_median2))

print("Contracción | Frecuencia media (Hz) | Frecuencia mediana (Hz)")
for r in resultados2:
    print(f"{r[0]:11.2f} | {r[1]:21.2f} | {r[2]:21.2f}")

"""

> f.

"""

from scipy.stats import linregress

resultados2 = np.array(resultados2)
contracciones2 = resultados2[:, 0]
f_media2 = resultados2[:, 1]
f_mediana2 = resultados2[:, 2]

print(f"Contracciones detectadas: {len(contracciones2)}")

slope_media, intercept_media, *_ = linregress(contracciones2, f_media2)
tendencia_media = intercept_media + slope_media * contracciones2

slope_mediana, intercept_mediana, *_ = linregress(contracciones2, f_mediana2)
tendencia_mediana = intercept_mediana + slope_mediana * contracciones2

plt.figure(figsize=(10,6))

plt.subplot(2,1,1)
plt.title("Frecuencia media")
plt.plot(contracciones2, f_media2, '*-', color='royalblue', label='Frecuencia Media')
plt.plot(contracciones2, tendencia_media, '--', color='maroon', alpha=0.8, label='Tendencia Media')
plt.xlabel("Número de Contracción")
plt.ylabel("Frecuencia (Hz)")
plt.legend()
plt.grid(True)

plt.subplot(2,1,2)
plt.title("Frecuencia mediana")
plt.plot(contracciones2, f_mediana2, '*-', color='seagreen', label='Frecuencia Mediana')
plt.plot(contracciones2, tendencia_mediana, '--', color='firebrick', alpha=0.8, label='Tendencia Mediana')
plt.xlabel("Número de Contracción")
plt.ylabel("Frecuencia (Hz)")
plt.legend()
plt.grid(True)

plt.tight_layout()
plt.show()

print(f"Pendiente Frecuencia Media:   {slope_media:.4f}")
print(f"Pendiente Frecuencia Mediana: {slope_mediana:.4f}")

if slope_media < 0 and slope_mediana < 0:
    print("\nAmbas pendientes son negativas lo que indica tendencia descendente clara. Indica que hay fatiga muscular progresiva.")
elif slope_media < 0 or slope_mediana < 0:
    print("\nSolo una frecuencia desciende lo que indica posible fatiga parcial.")
else:
    print("\nNo hay tendencia descendente lo que indica que no se observa fatiga muscular evidente.")

"""###**Parte C**


> a.


"""

import numpy as np
import matplotlib.pyplot as plt

fs = 10000

for i, seg in enumerate(segmentos2):
    N = len(seg)
    if N < 2:
        continue

    ventana = np.hanning(N)
    seg_ventana = seg * ventana

    fft_vals = np.fft.fft(seg_ventana)
    freqs = np.fft.fftfreq(N, 1/fs)

    fft_vals = fft_vals[:N//2]
    freqs = freqs[:N//2]
    potencia = np.abs(fft_vals)**2

"""

> b.

"""

magnitud = np.abs(fft_vals) / N
plt.figure(figsize=(8,4))
plt.semilogy(freqs, magnitud, color='darkslategray')
plt.title(f"Espectro de amplitud - Contracción {i+1}")
plt.xlabel("Frecuencia (Hz)")
plt.ylabel("Magnitud")
plt.grid(True, which='both', linestyle='--', alpha=0.7)
plt.tight_layout()
plt.show()

"""

> e.
"""

segmentos_filtrados = [senal_filtrada[ini:fin] for ini, fin in zip(inicios2, fines2)]

picos = []

for seg in segmentos_filtrados:
    N = len(seg)
    if N < 2:
        picos.append(np.nan)
        continue

    seg_ventana = seg * np.hanning(N)
    fft_vals = np.fft.fft(seg_ventana)
    freqs = np.fft.fftfreq(N, 1/fs)

    fft_vals = fft_vals[:N//2]
    freqs = freqs[:N//2]
    magnitud = np.abs(fft_vals) / N

    magnitud[0] = 0

    f_pico = freqs[np.argmax(magnitud)]
    picos.append(f_pico)

picos = np.array(picos)

n = 3

pico_primeras = np.nanmean(picos[:n])
pico_ultimas = np.nanmean(picos[-n:])

desplazamiento = pico_ultimas - pico_primeras

print(f"Pico promedio primeras contracciones: {pico_primeras:.2f} Hz")
print(f"Pico promedio últimas contracciones: {pico_ultimas:.2f} Hz")
print(f"Desplazamiento del pico: {desplazamiento:.2f} Hz")